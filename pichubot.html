<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="icon" href="images/icons/pikachu_72px.ico" type="image/x-icon" >
  <link rel="stylesheet" href="/pichubot/style.css" />
  <link rel="stylesheet" href="/pichubot/element-ui.css">
  <link href="https://fonts.googleapis.com/css?family=Noto+Sans+SC" rel="stylesheet">
  <title>皮丘Bot 使用说明 | Pichubot Useage - im0o.top</title>
</head>
<body>
  <canvas id="canvas"> </canvas>
    <div class="box">
      <div class="main-box">
        <p class="main-font">Pichu Bot - QQ机器人使用说明【旧版】</p>
            <ul>
            <p>1. 以（!/！）开头的消息会被皮丘识别为指令</p>
            <p>* 新版Pichubot暂时只有大学习统计功能</p>
            <p>2. 指令及用法</p>
            <ul>
                <li>[!帮助][!help] 查询帮助/查看使用说明</li>
                <li>[!抽签][!cq] 开始抽签（观音签 共100签）</li>
                <li>[!鸡汤][!cureword] 随机获取一碗鸡汤</li>
                <li>[!人话][!nbnhhsh]+[词语缩写] 查询缩写对应的人话</li>
                <div class="codebox">
                    <p>用法：!人话 nbnhhsh <br> #回复：以下是nbnhhsh的人话：能不能好好说话</p>
                </div>
                <li>[!机翻][!翻译][!百度翻译][!fanyi]+[目标语言]+[原文] 翻译语言</li>
                <div class="codebox">
                    <p>
                        用法：!翻译 zh hello world <br> #回复：hello world 的中文是：你好，世界<br>
                        支持的[<b>目标语言</b>]：中文, 英语, 日语, 韩语, 西班牙语, 法语, 泰语, 阿拉伯语, 俄语, 葡萄牙语, 粤语, 文言文<br>
                        也可以使用语言ID: zh, en, jp, kor, spa, fra, th, ara, ru, pt, yue, wyw
                    </p>
                </div>
            </ul>
            <p>3. 青年大学习统计功能</p>
            <p style="padding-left: 18px;">指令(均以大学习/dxx开头)：</p>
            <ul>
                <li>[!大学习][!dxx]+[查询][cx]</li>
                <div class="codebox">
                    <p>格式：！大学习 查询 <br> 回复：@you 本次青年大学习完成人数：n/all <br>未完成x人</p>
                </div>
                <li>[!大学习][!dxx]+[列出][list]</li>
                <li>[!大学习][!dxx]+[未完成][at]</li>
                <li>[!大学习][!dxx]+[重置][reset]</li>
                <li>[!大学习][!dxx]+[添加][add]+[@某人]</li>
                <li>[!大学习][!dxx]+[移除][remove]+[@某人]</li>
                <p>向 QQ:2773173293 申请并提交班级群需要做青年大学习同学的QQ列表即可自动统计青年大学习完成情况<br>
                <b>原理：</b>成员发送青年大学习完成图片自动检测并比对QQ列表，完成后将改成员状态设置为完成<br>
                <b>需注意：</b>青年大学习截图必须为全屏截图，不支持小窗</p>
                <div style="margin-top: -10px;display: inline;">
                    <p style="display: inline-flex;">[</p><a href="/blog/assets/download/附件-青年大学习信息提交表.xlsx">附件-青年大学习信息提交表.xlsx</a><p style="display: inline;">] 提交数据时 请把文件名字改为 群号+班级大学习信息提交表.xlsx </p>
                </div>
            </ul>
            <p>4. 更新日志</p>
            <ul>
                <div class="codebox">
                    2021.04.16 - 04.24 - 研究青年大学习成绩单API 更新青年大学习统计功能 修复bug 优化
                    <hr>
                    新的工程仓库地址: <a href="https://github.com/0ojixueseno0/go-Pichubot">https://github.com/0ojixueseno0/go-Pichubot</a> 该仓库不包含青年大学习功能
                    <hr>
                    2021.04.15 - 整合核心功能至mainbot pack 修复部分bug 优化回调
                    <hr>
                    2021.04.08 - 新增事件回调 长事件Example(示例)
                    <hr>
                    2021.03.20 - 分离函数至 Pichumod pack
                    <hr>
                    2021.03.19 - Go语言重构代码 基础完工
                    <hr>
                    2020.12.01 - 16:02:42: 优化代码 修复bug 修改大学习提示
                    <hr>
                    2020.12.01 - 14:48:47: 群号数据库完工 + 新增功能：添加完成/移除完成/列出未完成名单
                    <hr>
                    2020.12.01 - 09:43:15: sqlite3 group before(群组改为数据库存储[开工])
                    <hr>
                    2020.11.30 - 10:23:19: completed Group Messages
                    <hr>
                    2020.11.30 - 09:19:33: 修复bug 优化代码
                    <hr>
                    2020.11.26 - 21:04:29: 观音签准备
                    <hr>
                    2020.11.26 - 00:08:15: 初步完成大学习统计功能
                    <hr>
                    2020.11.25 - 20:53:43: CQ码解析完成
                    <hr>
                    2020.11.25 - 11:53:54: First commit
                </div>
            </ul>
            <p>5. 关于作者</p>
            <ul><p>Pichu Bot Authored by 0ojixueseno0 [QQ 2773173293]</p></ul>
            </ul>
      </div>
    </div>
  <script>
    function random(low, high) {
          return Math.random() * (high - low) + low;
      }
      
      class Visual {
          constructor() {
              this.canvas = document.querySelector("#canvas");
              this.context = this.canvas.getContext("2d");
              this.canvasWidth = 0;
              this.canvasHeight = 0;
              this.particleLength = 150;
              this.particles = [];
              this.particleMaxRadius = 8;
              this.handleResizeBind = this.handleResize.bind(this);
      
              this.initialize();
              this.render();
          }
      
          initialize() {
              this.resizeCanvas();
              for (let i = 0; i < this.particleLength; i++) {
                  this.particles.push(this.createParticle(i));
              }
              this.bind();
          }
      
          bind() {
              window.addEventListener("resize", this.handleResizeBind, false);
          }
      
          unbind() {
              window.removeEventListener("resize", this.handleResizeBind, false);
          }
      
          handleResize() {
              this.resizeCanvas();
          }
      
          resizeCanvas() {
              this.canvasWidth = document.body.offsetWidth;
              this.canvasHeight = document.body.offsetHeight;
              this.canvas.width = this.canvasWidth * window.devicePixelRatio;
              this.canvas.height = this.canvasHeight * window.devicePixelRatio;
              this.context = this.canvas.getContext("2d");
              this.context.scale(window.devicePixelRatio, window.devicePixelRatio);
          }
      
          createParticle(id, isRecreate) {
              const radius = random(1, this.particleMaxRadius);
              const x = isRecreate
                  ? -radius - random(this.particleMaxRadius * 2, this.canvasWidth)
                  : random(0, this.canvasWidth);
              let y = random(
                  this.canvasHeight / 2 - 150,
                  this.canvasHeight / 2 + 150
              );
              y += random(-100, 100);
              const alpha = random(0.05, 1);
      
              return {
                  id: id,
                  x: x,
                  y: y,
                  startY: y,
                  radius: radius,
                  defaultRadius: radius,
                  startAngle: 0,
                  endAngle: Math.PI * 2,
                  alpha: alpha,
                  color: { r: random(0, 100), g: random(0, 100), b: 255 },
                  speed: alpha + 1,
                  amplitude: random(50, 200),
                  isBurst: false,
              };
          }
      
          drawParticles() {
              this.particles.forEach((particle) => {
                  // 位置情報更新
                  this.moveParticle(particle);
                  // particle描画
                  this.context.beginPath();
                  this.context.fillStyle = `rgba(${particle.color.r}, ${particle.color.g}, ${particle.color.b}, ${particle.alpha})`;
                  this.context.arc(
                      particle.x,
                      particle.y,
                      particle.radius,
                      particle.startAngle,
                      particle.endAngle
                  );
                  this.context.fill();
              });
          }
      
          moveParticle(particle) {
              particle.x += particle.speed;
              particle.y =
                  particle.startY +
                  particle.amplitude * Math.sin(((particle.x / 5) * Math.PI) / 180);
          }
      
          render() {
              // canvas初期化
              this.context.clearRect(
                  0,
                  0,
                  this.canvasWidth + this.particleMaxRadius * 2,
                  this.canvasHeight
              );
      
              // particleを描画
              this.drawParticles();
      
              // 画面から消えたら新しいparticleに差し替え
              this.particles.forEach((particle) => {
                  if (particle.x - particle.radius >= this.canvasWidth) {
                      this.particles[particle.id] = this.createParticle(
                          particle.id,
                          true
                      );
                  }
              });
      
              requestAnimationFrame(this.render.bind(this));
          }
      }
      
      new Visual();
  </script>
</body>
</html>