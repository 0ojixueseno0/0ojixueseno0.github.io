<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="icon" href="images/icons/pikachu_72px.ico" type="image/x-icon" >
  <link rel="stylesheet" href="/pichubot/style.css" />
  <link rel="stylesheet" href="/pichubot/element-ui.css">
  <link href="https://fonts.googleapis.com/css?family=Noto+Sans+SC" rel="stylesheet">
  <title>皮丘Bot 使用说明 | Pichubot Useage - im0o.top</title>
<meta name="generator" content="Hexo 4.2.1"></head>
<body>
  <canvas id="canvas"> </canvas>
    <div class="box">
      <div class="main-box">
        <p class="main-font">Pichu Bot - QQ机器人使用说明</p>
        <ul>
          <p>1. 以（!/！）开头的消息会被皮丘识别为指令</p>
          <p>2. 皮丘可以干什么？</p>
          <ul>
            <li>向皮丘发送指令[!help]以查询帮助</li>
            <li>指令 [!cq] 开始抽签</li>
            <li>指令 [!鸡汤] 随机喝一碗鸡汤</li>
            <li>指令 [!人话 (缩写)] 查看缩写对应的人话</li>
            <p>用法：!人话 nbnhhsh #回复：以下是nbnhhsh的人话：能不能好好说话</p>
            <li>指令 [!机翻 (英文)] 英译中(百度翻译)</li>
            <p>向 QQ:2773173293 申请并提交班级群需要做青年大学习同学的QQ列表即可自动统计青年大学习完成情况<br>
            <b>原理：</b>成员发送青年大学习完成图片自动检测并比对QQ列表，完成后将改成员状态设置为完成<br>
            <b>需注意：</b>青年大学习截图必须为全屏截图，不支持小窗</p>
          </ul>
          <p>3. 关于作者</p>
          <ul><p>Pichu Bot Authored by 0ojixueseno0 [QQ 2773173293]</p></ul>
        </ul>

      </div>
    </div>
  <script>
    function random(low, high) {
          return Math.random() * (high - low) + low;
      }
      
      class Visual {
          constructor() {
              this.canvas = document.querySelector("#canvas");
              this.context = this.canvas.getContext("2d");
              this.canvasWidth = 0;
              this.canvasHeight = 0;
              this.particleLength = 150;
              this.particles = [];
              this.particleMaxRadius = 8;
              this.handleResizeBind = this.handleResize.bind(this);
      
              this.initialize();
              this.render();
          }
      
          initialize() {
              this.resizeCanvas();
              for (let i = 0; i < this.particleLength; i++) {
                  this.particles.push(this.createParticle(i));
              }
              this.bind();
          }
      
          bind() {
              window.addEventListener("resize", this.handleResizeBind, false);
          }
      
          unbind() {
              window.removeEventListener("resize", this.handleResizeBind, false);
          }
      
          handleResize() {
              this.resizeCanvas();
          }
      
          resizeCanvas() {
              this.canvasWidth = document.body.offsetWidth;
              this.canvasHeight = document.body.offsetHeight;
              this.canvas.width = this.canvasWidth * window.devicePixelRatio;
              this.canvas.height = this.canvasHeight * window.devicePixelRatio;
              this.context = this.canvas.getContext("2d");
              this.context.scale(window.devicePixelRatio, window.devicePixelRatio);
          }
      
          createParticle(id, isRecreate) {
              const radius = random(1, this.particleMaxRadius);
              const x = isRecreate
                  ? -radius - random(this.particleMaxRadius * 2, this.canvasWidth)
                  : random(0, this.canvasWidth);
              let y = random(
                  this.canvasHeight / 2 - 150,
                  this.canvasHeight / 2 + 150
              );
              y += random(-100, 100);
              const alpha = random(0.05, 1);
      
              return {
                  id: id,
                  x: x,
                  y: y,
                  startY: y,
                  radius: radius,
                  defaultRadius: radius,
                  startAngle: 0,
                  endAngle: Math.PI * 2,
                  alpha: alpha,
                  color: { r: random(0, 100), g: random(0, 100), b: 255 },
                  speed: alpha + 1,
                  amplitude: random(50, 200),
                  isBurst: false,
              };
          }
      
          drawParticles() {
              this.particles.forEach((particle) => {
                  // 位置情報更新
                  this.moveParticle(particle);
                  // particle描画
                  this.context.beginPath();
                  this.context.fillStyle = `rgba(${particle.color.r}, ${particle.color.g}, ${particle.color.b}, ${particle.alpha})`;
                  this.context.arc(
                      particle.x,
                      particle.y,
                      particle.radius,
                      particle.startAngle,
                      particle.endAngle
                  );
                  this.context.fill();
              });
          }
      
          moveParticle(particle) {
              particle.x += particle.speed;
              particle.y =
                  particle.startY +
                  particle.amplitude * Math.sin(((particle.x / 5) * Math.PI) / 180);
          }
      
          render() {
              // canvas初期化
              this.context.clearRect(
                  0,
                  0,
                  this.canvasWidth + this.particleMaxRadius * 2,
                  this.canvasHeight
              );
      
              // particleを描画
              this.drawParticles();
      
              // 画面から消えたら新しいparticleに差し替え
              this.particles.forEach((particle) => {
                  if (particle.x - particle.radius >= this.canvasWidth) {
                      this.particles[particle.id] = this.createParticle(
                          particle.id,
                          true
                      );
                  }
              });
      
              requestAnimationFrame(this.render.bind(this));
          }
      }
      
      new Visual();
  </script>
</body>
</html>